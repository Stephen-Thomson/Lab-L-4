"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateUnlockScriptOfChangeOutput = exports.validateUnlockScriptWithBsvSdk = exports.validateSubmitDirectCustomTransaction = exports.validateSABPPPTransaction = exports.validatePaymail = exports.validateOutputToRedeem = exports.validateFeeModel = exports.validateOutputTags = exports.validateOutputTag = exports.validateTxLabels = exports.validateTxLabel = exports.validateOutputGeneration = exports.validateInputSelection = exports.validateScript = exports.validateSatoshis = exports.validateDate = exports.validateSecondsSinceEpoch = exports.validateCreateTxOutput = exports.validateOutputDescription = exports.validateCustomInstructions = exports.validateTxNote = exports.validateTxRecipient = exports.validateBasketName = exports.validateTXID = exports.validateIdentityKey = void 0;
const sdk_1 = require("@bsv/sdk");
const ERR_DOJO_errors_1 = require("./ERR_DOJO_errors");
const ERR_errors_1 = require("./ERR_errors");
const utils_1 = require("./utils");
const verifyHelpers_1 = require("./verifyHelpers");
const CwiError_1 = require("./CwiError");
const ScriptTemplateSABPPP_1 = require("./ScriptTemplateSABPPP");
function validateIdentityKey(identityKey) {
    // First, we make sure the user has provided the required fields
    if (identityKey == null)
        throw new ERR_errors_1.ERR_UNAUTHORIZED('User identityKey not provided!');
    // Force the incoming identityKey value to be a compressed public key...
    if (identityKey.length > 66) {
        // A compressed public key is 33 hex digits.
        const pubkey = sdk_1.PublicKey.fromString(identityKey);
        identityKey = pubkey.toString();
    }
    if (identityKey.length !== 66)
        throw new ERR_errors_1.ERR_UNAUTHORIZED('User identityKey is invalid!');
    return identityKey;
}
exports.validateIdentityKey = validateIdentityKey;
function validateTXID(txid) {
    if (typeof txid === 'string') {
        const re = /[0-9A-Fa-f]{64}/g;
        if (!re.test(txid)) {
            throw new ERR_errors_1.ERR_TXID_INVALID();
        }
    }
    else {
        throw new ERR_errors_1.ERR_TXID_INVALID();
    }
}
exports.validateTXID = validateTXID;
function validateBasketName(name) {
    name = name.trim();
    if (name.length > 1000) {
        throw new ERR_DOJO_errors_1.ERR_DOJO_INVALID_BASKET_NAME();
    }
    return name;
}
exports.validateBasketName = validateBasketName;
function validateTxRecipient(recipient) {
    if (recipient === undefined)
        return undefined;
    if (typeof recipient !== 'string' || recipient.length > 100)
        throw new ERR_DOJO_errors_1.ERR_DOJO_INVALID_TX_RECIPIENT();
    validatePaymail(recipient);
    return recipient;
}
exports.validateTxRecipient = validateTxRecipient;
function validateTxNote(note) {
    if (note === undefined)
        return undefined;
    if (typeof note !== 'string' || note.length > 500)
        throw new ERR_DOJO_errors_1.ERR_DOJO_INVALID_NOTE();
    return note;
}
exports.validateTxNote = validateTxNote;
function validateCustomInstructions(s) {
    s = s.trim();
    if (s.length > 2500) {
        throw new ERR_DOJO_errors_1.ERR_DOJO_INVALID_CUSTOM_INSTRUCTIONS();
    }
    return s;
}
exports.validateCustomInstructions = validateCustomInstructions;
function validateOutputDescription(s) {
    s = s.trim();
    if (s.length > 255) {
        throw new ERR_DOJO_errors_1.ERR_DOJO_INVALID_OUTPUT_DESCRIPTION();
    }
    return s;
}
exports.validateOutputDescription = validateOutputDescription;
function validateCreateTxOutput(o) {
    if (typeof o !== 'object')
        throw new ERR_errors_1.ERR_BAD_REQUEST('Outputs must be objects.');
    validateSatoshis(o.satoshis);
    validateScript(o.script);
    if (o.description !== undefined)
        o.description = validateOutputDescription(o.description);
    if (o.basket !== undefined)
        o.basket = validateTxLabel(o.basket);
    if (o.customInstructions !== undefined)
        o.customInstructions = validateCustomInstructions(o.customInstructions);
    if (o.tags)
        o.tags = validateOutputTags(o.tags);
}
exports.validateCreateTxOutput = validateCreateTxOutput;
function validateSecondsSinceEpoch(time) {
    const date = new Date(time * 1000);
    if (date.getTime() / 1000 !== time || time < 1600000000 || time > 100000000000) {
        throw new ERR_DOJO_errors_1.ERR_DOJO_INVALID_TIME();
    }
    return date;
}
exports.validateSecondsSinceEpoch = validateSecondsSinceEpoch;
function validateDate(date) {
    let r = undefined;
    if (date instanceof Date)
        r = date;
    else if (date)
        r = new Date(date);
    return r;
}
exports.validateDate = validateDate;
function validateSatoshis(satoshis) {
    if (!Number.isInteger(satoshis) || satoshis < 0 || satoshis > 21e14) {
        throw new ERR_DOJO_errors_1.ERR_DOJO_INVALID_SATOSHIS();
    }
}
exports.validateSatoshis = validateSatoshis;
function validateScript(script) {
    const re = /^([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})*$/ig;
    if (typeof script !== 'string' || !re.test(script)) {
        throw new ERR_DOJO_errors_1.ERR_DOJO_INVALID_SCRIPT();
    }
    try {
        sdk_1.Script.fromHex(script);
    }
    catch (e) {
        throw new ERR_DOJO_errors_1.ERR_DOJO_INVALID_SCRIPT();
    }
}
exports.validateScript = validateScript;
function validateInputSelection(v) {
    let r;
    if ((v == null) || typeof v !== 'object') {
        r = {
            disable: false,
            baskets: ['default'],
            maxUnconfirmedChainLength: -1,
            includeSending: false
        };
    }
    else {
        if (typeof v.disable !== 'boolean')
            v.disable = false;
        if (typeof v.includeSending !== 'boolean')
            v.includeSending = false;
        if (!Array.isArray(v.baskets))
            v.baskets = ['default'];
        if (typeof v.maxUnconfirmedChainLength !== 'number')
            v.maxUnconfirmedChainLength = -1;
        r = {
            disable: v.baskets.length === 0 || v.disable,
            baskets: v.baskets,
            maxUnconfirmedChainLength: v.maxUnconfirmedChainLength,
            includeSending: v.includeSending
        };
    }
    return r;
}
exports.validateInputSelection = validateInputSelection;
function validateOutputGeneration(v) {
    let r;
    if (typeof v !== 'object') {
        r = {
            basket: 'default',
            method: 'auto'
        };
    }
    else {
        if (typeof v.basket !== 'string')
            v.basket = 'default';
        if (typeof v.method !== 'string' || v.method !== 'single')
            v.method = 'auto';
        r = {
            basket: v.basket,
            method: v.method
        };
    }
    return r;
}
exports.validateOutputGeneration = validateOutputGeneration;
function validateTxLabel(label) {
    label = label.trim();
    if (label.length > 150) {
        throw new ERR_DOJO_errors_1.ERR_DOJO_INVALID_TX_LABEL();
    }
    return label;
}
exports.validateTxLabel = validateTxLabel;
function validateTxLabels(v) {
    const r = [];
    if (typeof v !== 'undefined') {
        if (!Array.isArray(v))
            throw new ERR_errors_1.ERR_BAD_REQUEST('Transaction labels must be an array');
        if (v.length > 30)
            throw new ERR_errors_1.ERR_BAD_REQUEST('No more than 30 labels per transaction are allowed');
        if (new Set(v).size !== v.length)
            throw new ERR_errors_1.ERR_BAD_REQUEST('Duplicate transaction labels are not allowed');
        for (let i = 0; i < v.length; i++) {
            r[i] = validateTxLabel(v[i]);
        }
    }
    return r;
}
exports.validateTxLabels = validateTxLabels;
function validateOutputTag(tag) {
    tag = tag.trim();
    if (tag.length > 150) {
        throw new ERR_DOJO_errors_1.ERR_DOJO_INVALID_OUTPUT_TAG();
    }
    return tag;
}
exports.validateOutputTag = validateOutputTag;
function validateOutputTags(v) {
    const r = [];
    if (typeof v !== 'undefined') {
        if (!Array.isArray(v))
            throw new ERR_errors_1.ERR_BAD_REQUEST('Output tags must be an array');
        if (v.length > 30)
            throw new ERR_errors_1.ERR_BAD_REQUEST('No more than 30 tags per output are allowed');
        if (new Set(v).size !== v.length)
            throw new ERR_errors_1.ERR_BAD_REQUEST('Duplicate output tags are not allowed');
        for (let i = 0; i < v.length; i++) {
            r[i] = validateOutputTag(v[i]);
        }
    }
    return r;
}
exports.validateOutputTags = validateOutputTags;
function validateFeeModel(v) {
    const r = {
        model: 'sat/kb',
        value: 110
    };
    if (typeof v === 'object') {
        if (v.model !== 'sat/kb')
            throw new ERR_DOJO_errors_1.ERR_DOJO_UNKNOWN_FEE_MODEL(v.model);
        if (typeof v.value === 'number') {
            r.value = v.value;
        }
    }
    return r;
}
exports.validateFeeModel = validateFeeModel;
function validateOutputToRedeem(output) {
    if (typeof output.index !== 'number') {
        throw new ERR_DOJO_errors_1.ERR_DOJO_INVALID_REDEEM('index property is missing or invalid');
    }
    if (typeof output.unlockingScriptLength !== 'number') {
        throw new ERR_DOJO_errors_1.ERR_DOJO_INVALID_REDEEM('unlockingScriptLength property is missing or invalid');
    }
}
exports.validateOutputToRedeem = validateOutputToRedeem;
function validatePaymail(paymailHandle) {
    if (paymailHandle == null)
        throw new ERR_DOJO_errors_1.ERR_DOJO_INVALID_PAYMAIL_HANDLE('The paymail handle cannot be null.');
    if (typeof paymailHandle !== 'string')
        throw new ERR_DOJO_errors_1.ERR_DOJO_INVALID_PAYMAIL_HANDLE('The paymail handle must be a string.');
    const re = /^(([a-zA-Z0-9._-]+)@([a-zA-Z0-9]+)(\.|:)([a-zA-Z0-9]+))$/g;
    if (!re.test(paymailHandle) || paymailHandle.length > 128) {
        throw new ERR_DOJO_errors_1.ERR_DOJO_INVALID_PAYMAIL_HANDLE('The paymail handle must follow e-mail address formatting rules and not be longer than 128 characters.');
    }
}
exports.validatePaymail = validatePaymail;
function validateSABPPPTransaction(transaction) {
    if (typeof transaction !== 'object')
        throw new ERR_errors_1.ERR_INVALID_PARAMETER('transaction', 'an object');
    if (!Array.isArray(transaction.outputs))
        throw new ERR_errors_1.ERR_INVALID_PARAMETER('transaction.outputs', 'an array');
    if (transaction.outputs.length < 1)
        throw new ERR_errors_1.ERR_INVALID_PARAMETER('transaction.outputs', 'of length greater than zero');
    if (!transaction.outputs.every(x => typeof x === 'object' &&
        typeof x.derivationSuffix === 'string'))
        throw new ERR_errors_1.ERR_INVALID_PARAMETER('transaction.outputs', 'have derivationSuffix');
    return transaction;
}
exports.validateSABPPPTransaction = validateSABPPPTransaction;
function validateSubmitDirectCustomTransaction(transaction) {
    if (typeof transaction !== 'object')
        throw new ERR_errors_1.ERR_INVALID_PARAMETER('transaction', 'an object');
    if (!Array.isArray(transaction.outputs))
        throw new ERR_errors_1.ERR_INVALID_PARAMETER('transaction.outputs', 'an array');
    if (transaction.outputs.length < 1)
        throw new ERR_errors_1.ERR_INVALID_PARAMETER('transaction.outputs', 'of length greater than zero');
    if (!transaction.outputs.every(x => typeof x === 'object' &&
        typeof x.customInstructions === 'string' &&
        typeof x.basket === 'string' && x.basket !== 'default'))
        throw new ERR_errors_1.ERR_INVALID_PARAMETER('transaction.outputs', 'have customInstructions and valid basket other than "default"');
    return transaction;
}
exports.validateSubmitDirectCustomTransaction = validateSubmitDirectCustomTransaction;
function validateUnlockScriptWithBsvSdk(spendingTx, vin, lockingScript, amount) {
    var _a;
    if (typeof spendingTx === "string" || Array.isArray(spendingTx) || Buffer.isBuffer(spendingTx))
        spendingTx = sdk_1.Transaction.fromHex((0, utils_1.asString)(spendingTx));
    if (typeof lockingScript === "string" || Array.isArray(lockingScript) || Buffer.isBuffer(lockingScript))
        lockingScript = sdk_1.Script.fromHex((0, utils_1.asString)(lockingScript));
    const input = spendingTx.inputs[vin];
    const sourceTXID = (0, verifyHelpers_1.verifyTruthy)(input.sourceTXID ? input.sourceTXID : (_a = input.sourceTransaction) === null || _a === void 0 ? void 0 : _a.id("hex"));
    const spend = new sdk_1.Spend({
        sourceTXID,
        sourceOutputIndex: input.sourceOutputIndex,
        sourceSatoshis: amount,
        lockingScript,
        transactionVersion: spendingTx.version,
        otherInputs: spendingTx.inputs.filter((v, i) => i !== vin),
        inputIndex: vin,
        unlockingScript: (0, verifyHelpers_1.verifyTruthy)(input.unlockingScript),
        outputs: spendingTx.outputs,
        inputSequence: input.sequence,
        lockTime: spendingTx.lockTime
    });
    const valid = spend.validate();
    return valid;
}
exports.validateUnlockScriptWithBsvSdk = validateUnlockScriptWithBsvSdk;
async function validateUnlockScriptOfChangeOutput(output, privateKey) {
    try {
        const sourceTXID = (0, verifyHelpers_1.verifyTruthy)(output.txid);
        const sourceOutputIndex = (0, verifyHelpers_1.verifyTruthy)(output.vout);
        const lockingScript = (0, utils_1.asString)((0, verifyHelpers_1.verifyTruthy)(output.outputScript));
        const satoshis = (0, verifyHelpers_1.verifyTruthy)(output.amount);
        const derivationPrefix = (0, verifyHelpers_1.verifyTruthy)(output.derivationPrefix);
        const derivationSuffix = (0, verifyHelpers_1.verifyTruthy)(output.derivationSuffix);
        const publicKey = output.senderIdentityKey || (0, utils_1.identityKeyFromPrivateKey)(privateKey);
        const sabppp = new ScriptTemplateSABPPP_1.ScriptTemplateSABPPP({ derivationPrefix, derivationSuffix });
        const unlockingScriptTemplate = sabppp.unlock(privateKey, publicKey, satoshis, (0, utils_1.asBsvSdkScript)(lockingScript));
        const tx = new sdk_1.Transaction();
        tx.addInput({
            sourceTXID,
            unlockingScriptTemplate,
            sourceOutputIndex,
            sequence: 0xffffffff
        });
        await tx.sign();
        const ok = validateUnlockScriptWithBsvSdk(tx, 0, (0, utils_1.asBsvSdkScript)(lockingScript), satoshis);
        if (!ok)
            return new ERR_errors_1.ERR_INVALID_PARAMETER("test unlock failed");
        return undefined;
    }
    catch (eu) {
        const e = CwiError_1.CwiError.fromUnknown(eu);
        return e;
    }
}
exports.validateUnlockScriptOfChangeOutput = validateUnlockScriptOfChangeOutput;
//# sourceMappingURL=validateHelpers.js.map