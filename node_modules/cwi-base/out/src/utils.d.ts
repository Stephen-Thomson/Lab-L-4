/// <reference types="node" />
import { PublicKey, PrivateKey, Transaction, Script } from '@bsv/sdk';
import { stampLog, stampLogFormat } from '@babbage/sdk-ts';
import { IdentityGroupMember, TrustEvaluatorParams } from './Api/TrustTransformerApi';
export { stampLog, stampLogFormat };
/**
 * Tests if all `bits` are set in `what`.
 *
 * @param what value being tested for set bits.
 * @param bits union of bits to test.
 * @returns true iff all `bits` are set in `what`
 */
export declare function bitsAreSet(what: number, bits: number): boolean;
/**
 * Returns an await'able Promise that resolves in the given number of msecs.
 * @publicbody
 */
export declare function wait(msecs: number): Promise<void>;
/**
 * @returns count cryptographically secure random bytes as Buffer
 */
export declare function randomBytes(count: number): Buffer;
/**
 * @returns count cryptographically secure random bytes as hex encoded string
 */
export declare function randomBytesHex(count: number): string;
/**
 * @returns count cryptographically secure random bytes as base64 encoded string
 */
export declare function randomBytesBase64(count: number): string;
/**
 * @param min minimum value to return
 * @param max greater than maximum value returned
 * @returns a weakly randomized value in the range from min to less than max.
 * @throws ERR_INVALID_PARAMETER when max is less than min.
 * @publicbody
 */
export declare function randomMinMax(min: number, max: number): number;
/**
 * Shuffle an array of items.
 *
 * This is not a cryptographically strong shuffle.
 *
 * Run time is O(n)
*
 * @returns original `array` with contents shuffled
 * @publicbody
 */
export declare function shuffleArray<T>(array: T[]): T[];
/**
 * Coerce a value to Buffer if currently encoded as a string or
 * @param val Buffer or string or number[]. If string, encoding param applies. If number[], Buffer.from constructor is used.
 * @param encoding defaults to 'hex'. Only applies to val of type string
 * @returns input val if it is a Buffer or new Buffer from string val
 * @publicbody
 */
export declare function asBuffer(val: Buffer | string | number[], encoding?: BufferEncoding): Buffer;
/**
 * Coerce a value to an encoded string if currently a Buffer or number[]
 * @param val Buffer or string or number[]. If string, encoding param applies. If number[], Buffer.from constructor is used.
 * @param encoding defaults to 'hex'
 * @returns input val if it is a string; or if number[], first converted to Buffer then as Buffer; if Buffer encoded using `encoding`
 * @publicbody
 */
export declare function asString(val: Buffer | string | number[], encoding?: BufferEncoding): string;
/**
 * Calculate the SHA256 hash of a Buffer.
 * @returns sha256 hash of buffer contents.
 * @publicbody
 */
export declare function sha256Hash(buffer: Buffer): Buffer;
/**
 * Calculate the SHA256 hash of the SHA256 hash of a Buffer.
 * @param data is Buffer or hex encoded string
 * @returns double sha256 hash of buffer contents, byte 0 of hash first.
 * @publicbody
 */
export declare function doubleSha256HashLE(data: string | Buffer, encoding?: BufferEncoding): Buffer;
/**
 * Calculate the SHA256 hash of the SHA256 hash of a Buffer.
 * @param data is Buffer or hex encoded string
 * @returns reversed (big-endian) double sha256 hash of data, byte 31 of hash first.
 * @publicbody
 */
export declare function doubleSha256BE(data: string | Buffer, encoding?: BufferEncoding): Buffer;
/**
 * Returns a copy of a Buffer with byte order reversed.
 * @returns new buffer with byte order reversed.
 * @publicbody
 */
export declare function swapByteOrder(buffer: Buffer): Buffer;
/**
 * @param num a number value in the Uint32 value range
 * @param littleEndian true for little-endian byte order in Buffer
 * @returns four byte buffer with Uint32 number encoded
 * @publicbody
 */
export declare function convertUint32ToBuffer(num: number, littleEndian?: boolean): Buffer;
/**
 * @param buffer four byte buffer with Uint32 number encoded
 * @param littleEndian true for little-endian byte order in Buffer
 * @returns a number value in the Uint32 value range
 * @publicbody
 */
export declare function convertBufferToUint32(buffer: Buffer, littleEndian?: boolean): number;
/**
 * Returns the byte size required to encode number as Bitcoin VarUint
 * @publicbody
 */
export declare function varUintSize(val: number): 1 | 3 | 5 | 9;
/**
 * Reads a Bitcoin VarUInt from buffer at an offset.
 *
 * Returns updated offset.
 * @publicbody
 */
export declare function readVarUint32LE(buffer: Buffer, offset: number): {
    val: number;
    offset: number;
};
/**
 * Writes a Bitcoin VarUInt to a buffer at an offset.
 *
 * Returns updated offset.
 * @publicbody
 */
export declare function writeVarUint32LE(val: number, buffer: Buffer, offset: number): number;
/**
 * Computes merkle root from transaction hash and TSC proof data.
 *
 * Note that it is essential to confirm that the txid is the double sha256 hash of
 * the transaction.
 *
 * To prove that txid is the last transaction in its block, at every level,
 * if computed is left side, then provided must equal computed.
 *
 * Specification Reference: https://tsc.bitcoinassociation.net/standards/merkle-proof-standardised-format/
 *
 * @param index index of transaction being proven in block
 * @param txid hash of transaction being proven
 * @param nodes tip to root, proof provided intermediate hash values
 * @returns computed merkle tree root for comparison to known root.
 */
export declare function computeRootFromMerkleProofNodes(index: number, txid: string | Buffer, nodes: string[] | Buffer): Buffer;
/**
 * Coerce the 32 byte hash value for a merkle tree parent node given its left and right child node hashes.
 *
 * @param leftNode 32 byte hash as hex string or Buffer
 * @param rightNode 32 byte hash as hex string or Buffer
 * @publicbody
 */
export declare function computeMerkleTreeParent(leftNode: string | Buffer, rightNode: string | Buffer): Buffer;
/**
 * Coerce a bsv transaction encoded as a hex string, serialized Buffer, or Transaction to Transaction
 * If tx is already a Transaction, just return it.
 * @publicbody
 */
export declare function asBsvSdkTx(tx: string | Buffer | Transaction): Transaction;
/**
 * Coerce a bsv script encoded as a hex string, serialized Buffer, or Script to Script
 * If script is already a Script, just return it.
 * @publicbody
 */
export declare function asBsvSdkScript(script: string | Buffer | Script): Script;
/**
 * @param privKey bitcoin private key in 32 byte hex string form
 * @returns @bsv/sdk PrivateKey
 */
export declare function asBsvSdkPrivateKey(privKey: string): PrivateKey;
/**
 * @param pubKey bitcoin public key in standard compressed key hex string form
 * @returns @bsv/sdk PublicKey
 */
export declare function asBsvSdkPublickKey(pubKey: string): PublicKey;
/**
 * For a bitcoin transaction in hex string, Buffer or parsed Transaction form,
 *
 * returns deduplicated array of the input's outpoint transaction hashes (txids).
 *
 * @publicbody
 */
export declare function getInputTxIds(tx: string | Buffer | Transaction): string[];
/**
 * Returns the Identity Key value associated with a private key.
 * @param privKey as hex encoded 32 byte value
 * @returns hex encoded Identity Key.
 */
export declare function identityKeyFromPrivateKey(privKey: string): string;
/**
 * returns most recent of two dates or undefined if both are null or undefined.
 * @publicbody
 */
export declare function maxDate(d1: Date | null | undefined, d2: Date | null | undefined): Date | undefined;
/**
 * returns least recent of two dates or undefined if either date is null or undefined.
 * @publicbody
 */
export declare function minDate(d1: Date | null | undefined, d2: Date | null | undefined): Date | undefined;
/**
 * Helper function for evaluating if an entity meets the trust threshold of the user
 * @param {object} obj all params given in an object
 * @param {object} obj.settings contains the user's setting information
 * @param {object} obj.results the results returned from a Signia lookup
 */
export declare function transformResultsWithTrust({ settings, certifiers, results }: TrustEvaluatorParams): IdentityGroupMember[];
//# sourceMappingURL=utils.d.ts.map