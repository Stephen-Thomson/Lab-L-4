"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const sdk_1 = require("@bsv/sdk");
const Hash_1 = require("@bsv/sdk/dist/types/src/primitives/Hash");
const utils_1 = require("@bsv/sdk/dist/types/src/primitives/utils");
/**
 * ScriptTemplateP2PKH (Pay To Public Key Hash) class implementing ScriptTemplate.
 *
 * THIS IS AN EXTENSION TO THE P2PKH CLASS IN @bsv/sdk THAT SHOULD BE MERGED.
 * THE EXTENSION IS IN unlock, ALLOWING INPUTS WITHOUT sourceTransaction TO BE SIGNED.
 *
 * This class provides methods to create Pay To Public Key Hash locking and unlocking scripts, including the unlocking of P2PKH UTXOs with the private key.
 */
class ScriptTemplateP2PKH {
    /**
     * Creates a P2PKH locking script for a given public key hash or address string
     *
     * @param {number[] | string} pubkeyhash or address - An array or address representing the public key hash.
     * @returns {LockingScript} - A P2PKH locking script.
     */
    lock(pubkeyhash) {
        let data;
        if (typeof pubkeyhash === 'string') {
            const hash = (0, utils_1.fromBase58Check)(pubkeyhash);
            if (hash.prefix[0] !== 0x00 && hash.prefix[0] !== 0x6f)
                throw new Error('only P2PKH is supported');
            data = hash.data;
        }
        else {
            data = pubkeyhash;
        }
        return new sdk_1.LockingScript([
            { op: sdk_1.OP.OP_DUP },
            { op: sdk_1.OP.OP_HASH160 },
            { op: data.length, data },
            { op: sdk_1.OP.OP_EQUALVERIFY },
            { op: sdk_1.OP.OP_CHECKSIG }
        ]);
    }
    /**
     * Creates a function that generates a P2PKH unlocking script along with its signature and length estimation.
     *
     * The returned object contains:
     * 1. `sign` - A function that, when invoked with a transaction and an input index,
     *    produces an unlocking script suitable for a P2PKH locked output.
     * 2. `estimateLength` - A function that returns the estimated length of the unlocking script in bytes.
     *
     * @param {PrivateKey} privateKey - The private key used for signing the transaction.
     * @param {'all'|'none'|'single'} signOutputs - The signature scope for outputs.
     * @param {boolean} anyoneCanPay - Flag indicating if the signature allows for other inputs to be added later.
     * @param {number} sourceSatoshis - Optional. The amount being unlocked. Otherwise the input.sourceTransaction is required.
     * @param {Script} lockingScript - Optional. The lockinScript. Otherwise the input.sourceTransaction is required.
     * @returns {Object} - An object containing the `sign` and `estimateLength` functions.
     */
    unlock(privateKey, signOutputs = 'all', anyoneCanPay = false, sourceSatoshis, lockingScript) {
        return {
            sign: async (tx, inputIndex) => {
                var _a, _b, _c;
                let signatureScope = sdk_1.TransactionSignature.SIGHASH_FORKID;
                if (signOutputs === 'all') {
                    signatureScope |= sdk_1.TransactionSignature.SIGHASH_ALL;
                }
                if (signOutputs === 'none') {
                    signatureScope |= sdk_1.TransactionSignature.SIGHASH_NONE;
                }
                if (signOutputs === 'single') {
                    signatureScope |= sdk_1.TransactionSignature.SIGHASH_SINGLE;
                }
                if (anyoneCanPay) {
                    signatureScope |= sdk_1.TransactionSignature.SIGHASH_ANYONECANPAY;
                }
                const input = tx.inputs[inputIndex];
                const otherInputs = tx.inputs.filter((_, index) => index !== inputIndex);
                const sourceTXID = input.sourceTXID ? input.sourceTXID : (_a = input.sourceTransaction) === null || _a === void 0 ? void 0 : _a.id('hex');
                if (!sourceTXID) {
                    throw new Error('The input sourceTXID or sourceTransaction is required for transaction signing.');
                }
                sourceSatoshis || (sourceSatoshis = (_b = input.sourceTransaction) === null || _b === void 0 ? void 0 : _b.outputs[input.sourceOutputIndex].satoshis);
                if (!sourceSatoshis) {
                    throw new Error('The sourceSatoshis or input sourceTransaction is required for transaction signing.');
                }
                lockingScript || (lockingScript = (_c = input.sourceTransaction) === null || _c === void 0 ? void 0 : _c.outputs[input.sourceOutputIndex].lockingScript);
                if (!lockingScript) {
                    throw new Error('The lockingScript or input sourceTransaction is required for transaction signing.');
                }
                const preimage = sdk_1.TransactionSignature.format({
                    sourceTXID,
                    sourceOutputIndex: input.sourceOutputIndex,
                    sourceSatoshis,
                    transactionVersion: tx.version,
                    otherInputs,
                    inputIndex,
                    outputs: tx.outputs,
                    inputSequence: input.sequence,
                    subscript: lockingScript,
                    lockTime: tx.lockTime,
                    scope: signatureScope
                });
                const rawSignature = privateKey.sign((0, Hash_1.sha256)(preimage));
                const sig = new sdk_1.TransactionSignature(rawSignature.r, rawSignature.s, signatureScope);
                const sigForScript = sig.toChecksigFormat();
                const pubkeyForScript = privateKey.toPublicKey().encode(true);
                return new sdk_1.UnlockingScript([
                    { op: sigForScript.length, data: sigForScript },
                    { op: pubkeyForScript.length, data: pubkeyForScript }
                ]);
            },
            estimateLength: async () => {
                // public key (1+33) + signature (1+71)
                // Note: We add 1 to each element's length because of the associated OP_PUSH
                return 106;
            }
        };
    }
}
exports.default = ScriptTemplateP2PKH;
//# sourceMappingURL=ScriptTemplageP2PKH.js.map