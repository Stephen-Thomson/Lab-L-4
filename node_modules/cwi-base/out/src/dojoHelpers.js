"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.restoreUserStateEntities = exports.verifyBufferOrObjectOrUndefined = exports.verifyBufferOrObjectOrNull = exports.verifyBufferOrObject = exports.createBabbageServiceChargeOutput = exports.lockScriptWithKeyOffsetFromPubKey = exports.offsetPubKey = exports.offsetPrivKey = exports.transactionSize = exports.transactionOutputSize = exports.transactionInputSize = void 0;
const _1 = require(".");
const sdk_1 = require("@bsv/sdk");
/**
 * @param scriptSize byte length of input script
 * @returns serialized byte length a transaction input
 */
function transactionInputSize(scriptSize) {
    return 32 + // txid
        4 + // vout
        (0, _1.varUintSize)(scriptSize) + // script length, this is already in bytes
        scriptSize + // script
        4; // sequence number
}
exports.transactionInputSize = transactionInputSize;
/**
 * @param scriptSize byte length of output script
 * @returns serialized byte length a transaction output
 */
function transactionOutputSize(scriptSize) {
    return (0, _1.varUintSize)(scriptSize) + // output script length, from script encoded as hex string
        scriptSize + // output script
        8; // output amount (satoshis)
}
exports.transactionOutputSize = transactionOutputSize;
/**
 * Compute the serialized binary transaction size in bytes
 * given the number of inputs and outputs,
 * and the size of each script.
 * @param inputs array of input script lengths, in bytes
 * @param outputs array of output script lengths, in bytes
 * @returns total transaction size in bytes
 */
function transactionSize(inputs, outputs) {
    return 4 + // Version
        (0, _1.varUintSize)(inputs.length) + // Number of inputs
        inputs.reduce((a, e) => a + transactionInputSize(e), 0) + // all inputs
        (0, _1.varUintSize)(outputs.length) + // Number of outputs
        outputs.reduce((a, e) => a + transactionOutputSize(e), 0) + // all outputs
        4; // lock time
}
exports.transactionSize = transactionSize;
function keyOffsetToHashedSecret(pub, keyOffset) {
    let offset;
    if (keyOffset !== undefined && typeof keyOffset === 'string') {
        if (keyOffset.length === 64)
            offset = sdk_1.PrivateKey.fromString(keyOffset, 'hex');
        else
            offset = sdk_1.PrivateKey.fromWif(keyOffset);
    }
    else {
        offset = sdk_1.PrivateKey.fromRandom();
        keyOffset = offset.toWif();
    }
    const sharedSecret = Buffer.from(pub.mul(offset).encode(true, undefined));
    const hashedSecret = (0, _1.sha256Hash)(sharedSecret);
    return { hashedSecret: new sdk_1.BigNumber(Array.from(hashedSecret)), keyOffset };
}
function offsetPrivKey(privKey, keyOffset) {
    const priv = sdk_1.PrivateKey.fromWif(privKey);
    const pub = priv.toPublicKey();
    const r = keyOffsetToHashedSecret(pub, keyOffset);
    const bn = priv.add(r.hashedSecret).mod(new sdk_1.Curve().n);
    const offsetPrivKey = new sdk_1.PrivateKey(bn).toWif();
    return { offsetPrivKey, keyOffset: r.keyOffset };
}
exports.offsetPrivKey = offsetPrivKey;
function offsetPubKey(pubKey, keyOffset) {
    const pub = sdk_1.PublicKey.fromString(pubKey);
    const r = keyOffsetToHashedSecret(pub, keyOffset);
    // The hashed secret is multiplied by the generator point.
    const point = new sdk_1.Curve().g.mul(r.hashedSecret);
    // The resulting point is added to the recipient public key.
    const offsetPubKey = new sdk_1.PublicKey(pub.add(point));
    return { offsetPubKey: offsetPubKey.toString(), keyOffset: r.keyOffset };
}
exports.offsetPubKey = offsetPubKey;
function lockScriptWithKeyOffsetFromPubKey(pubKey, keyOffset) {
    const r = offsetPubKey(pubKey, keyOffset);
    const offsetPub = sdk_1.PublicKey.fromString(r.offsetPubKey);
    const hash = offsetPub.toHash();
    const script = new sdk_1.P2PKH().lock(hash).toHex();
    return { script, keyOffset: r.keyOffset };
}
exports.lockScriptWithKeyOffsetFromPubKey = lockScriptWithKeyOffsetFromPubKey;
function createBabbageServiceChargeOutput(fee = 200) {
    // Derive a new public key to use for each commission to increase privacy
    const BABBAGE_PUBLIC_KEY_HEX = '0397742eaef6c7f08c4aa057397d45529f93ab90345b84ce5a5aac06ea9cdd132e';
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    const { script, keyOffset } = lockScriptWithKeyOffsetFromPubKey(BABBAGE_PUBLIC_KEY_HEX);
    return {
        script,
        satoshis: fee,
        keyOffset
    };
}
exports.createBabbageServiceChargeOutput = createBabbageServiceChargeOutput;
/**
 * Buffers sent across HTTP may not be restored correctly.
 *
 * Detect these situations and restore and Buffers.
 */
function verifyBufferOrObject(v) {
    if (Buffer.isBuffer(v))
        return v;
    if ('type' in v && v.type === 'Buffer' && 'data' in v && Array.isArray(v.data)) {
        return Buffer.from(v.data);
    }
    throw new _1.ERR_INTERNAL('Unexpected buffer encoding');
}
exports.verifyBufferOrObject = verifyBufferOrObject;
function verifyBufferOrObjectOrNull(v) {
    if (v == null)
        return null;
    return verifyBufferOrObject(v);
}
exports.verifyBufferOrObjectOrNull = verifyBufferOrObjectOrNull;
function verifyBufferOrObjectOrUndefined(v) {
    if (v == null)
        return undefined;
    return verifyBufferOrObject(v);
}
exports.verifyBufferOrObjectOrUndefined = verifyBufferOrObjectOrUndefined;
/**
 * Entities sent across HTTP may not have Date and Buffer properties restored correctly.
 *
 * Detect these situations and restore contained values as Dates and Buffers.
 */
function restoreUserStateEntities(state) {
    state.user.created_at = (0, _1.validateDate)(state.user.created_at);
    state.user.updated_at = (0, _1.validateDate)(state.user.updated_at);
    // Run through entities with timestamps (ewts) to make sure they are Dates, not strings.
    const ewts = [
        state.baskets, state.certificateFields, state.certificates, state.commissions, state.mapiResponses,
        state.outputs, state.provenTxReqs, state.provenTxs, state.txLabelMaps, state.txLabels, state.txs
    ];
    for (const ewt of ewts) {
        for (let i = 0; i < ewt.length; i++) {
            const ei = ewt[i];
            ei.created_at = (0, _1.validateDate)(ei.created_at);
            ei.updated_at = (0, _1.validateDate)(ei.updated_at);
        }
    }
    for (let i = 0; i < state.provenTxs.length; i++) {
        /**
             * entityIn: The incoming entity from state being merged.
             */
        const ei = state.provenTxs[i];
        ei.nodes = verifyBufferOrObject(ei.nodes);
        ei.rawTx = verifyBufferOrObject(ei.rawTx);
        ei.blockHash = verifyBufferOrObject(ei.blockHash);
        ei.merkleRoot = verifyBufferOrObject(ei.merkleRoot);
    }
    for (let i = 0; i < state.provenTxReqs.length; i++) {
        const ei = state.provenTxReqs[i];
        ei.rawTx = verifyBufferOrObjectOrUndefined(ei.rawTx);
    }
    for (let i = 0; i < state.txs.length; i++) {
        const ei = state.txs[i];
        ei.rawTransaction = verifyBufferOrObjectOrNull(ei.rawTransaction);
    }
    for (let i = 0; i < state.commissions.length; i++) {
        const ei = state.commissions[i];
        ei.outputScript = verifyBufferOrObjectOrNull(ei.outputScript);
    }
    for (let i = 0; i < state.outputs.length; i++) {
        const ei = state.outputs[i];
        ei.outputScript = verifyBufferOrObjectOrNull(ei.outputScript);
    }
}
exports.restoreUserStateEntities = restoreUserStateEntities;
//# sourceMappingURL=dojoHelpers.js.map