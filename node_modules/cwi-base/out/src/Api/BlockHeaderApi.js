"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.toLiveBlockHeader = exports.toBlockHeader = exports.toBaseBlockHeader = exports.toLiveBlockHeaderHex = exports.toBlockHeaderHex = exports.toBaseBlockHeaderHex = exports.isLiveBlockHeaderHex = exports.isBlockHeaderHex = exports.isBaseBlockHeaderHex = exports.isLiveBlockHeader = exports.isBlockHeader = exports.isBaseBlockHeader = exports.isLive = void 0;
const utils_1 = require("../utils");
//
// TYPE GUARDS
//
/**
 * Type guard function.
 * @publicbody
 */
function isLive(header) {
    return header.headerId !== undefined;
}
exports.isLive = isLive;
/**
 * Type guard function.
 * @publicbody
 */
function isBaseBlockHeader(header) {
    return Buffer.isBuffer(header.previousHash);
}
exports.isBaseBlockHeader = isBaseBlockHeader;
/**
 * Type guard function.
 * @publicbody
 */
function isBlockHeader(header) {
    return ('height' in header) && Buffer.isBuffer(header.previousHash);
}
exports.isBlockHeader = isBlockHeader;
/**
 * Type guard function.
 * @publicbody
 */
function isLiveBlockHeader(header) {
    return 'chainwork' in header && Buffer.isBuffer(header.previousHash);
}
exports.isLiveBlockHeader = isLiveBlockHeader;
/**
 * Type guard function.
 * @publicbody
 */
function isBaseBlockHeaderHex(header) {
    return (typeof header.previousHash === 'string');
}
exports.isBaseBlockHeaderHex = isBaseBlockHeaderHex;
/**
 * Type guard function.
 * @publicbody
 */
function isBlockHeaderHex(header) {
    return ('height' in header) && (typeof header.previousHash === 'string');
}
exports.isBlockHeaderHex = isBlockHeaderHex;
/**
 * Type guard function.
 * @publicbody
 */
function isLiveBlockHeaderHex(header) {
    return 'chainwork' in header && (typeof header.previousHash === 'string');
}
exports.isLiveBlockHeaderHex = isLiveBlockHeaderHex;
/**
 * Type conversion function.
 * @publicbody
 */
function toBaseBlockHeaderHex(header) {
    return {
        version: header.version,
        previousHash: (0, utils_1.asString)(header.previousHash),
        merkleRoot: (0, utils_1.asString)(header.merkleRoot),
        time: header.time,
        bits: header.bits,
        nonce: header.nonce
    };
}
exports.toBaseBlockHeaderHex = toBaseBlockHeaderHex;
/**
 * Type conversion function.
 * @publicbody
 */
function toBlockHeaderHex(header) {
    return {
        version: header.version,
        previousHash: (0, utils_1.asString)(header.previousHash),
        merkleRoot: (0, utils_1.asString)(header.merkleRoot),
        time: header.time,
        bits: header.bits,
        nonce: header.nonce,
        height: header.height,
        hash: (0, utils_1.asString)(header.hash)
    };
}
exports.toBlockHeaderHex = toBlockHeaderHex;
/**
 * Type conversion function.
 * @publicbody
 */
function toLiveBlockHeaderHex(header) {
    return Object.assign(Object.assign({}, header), { previousHash: (0, utils_1.asString)(header.previousHash), merkleRoot: (0, utils_1.asString)(header.merkleRoot), hash: (0, utils_1.asString)(header.hash), chainWork: (0, utils_1.asString)(header.chainWork) });
}
exports.toLiveBlockHeaderHex = toLiveBlockHeaderHex;
/**
 * Type conversion function.
 * @publicbody
 */
function toBaseBlockHeader(header) {
    return {
        version: header.version,
        previousHash: (0, utils_1.asBuffer)(header.previousHash),
        merkleRoot: (0, utils_1.asBuffer)(header.merkleRoot),
        time: header.time,
        bits: header.bits,
        nonce: header.nonce
    };
}
exports.toBaseBlockHeader = toBaseBlockHeader;
/**
 * Type conversion function.
 * @publicbody
 */
function toBlockHeader(header) {
    return {
        version: header.version,
        previousHash: (0, utils_1.asBuffer)(header.previousHash),
        merkleRoot: (0, utils_1.asBuffer)(header.merkleRoot),
        time: header.time,
        bits: header.bits,
        nonce: header.nonce,
        height: header.height,
        hash: (0, utils_1.asBuffer)(header.hash)
    };
}
exports.toBlockHeader = toBlockHeader;
/**
 * Type conversion function.
 * @publicbody
 */
function toLiveBlockHeader(header) {
    return Object.assign(Object.assign({}, header), { previousHash: (0, utils_1.asBuffer)(header.previousHash), merkleRoot: (0, utils_1.asBuffer)(header.merkleRoot), hash: (0, utils_1.asBuffer)(header.hash), chainWork: (0, utils_1.asBuffer)(header.chainWork) });
}
exports.toLiveBlockHeader = toLiveBlockHeader;
//# sourceMappingURL=BlockHeaderApi.js.map