"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.genesisBuffer = exports.genesisHeaderHex = exports.deserializeBlockHeader = exports.serializeBlockHeader = exports.blockHash = void 0;
const utils_1 = require("./utils");
const BlockHeaderApi_1 = require("./Api/BlockHeaderApi");
/**
 * Computes double sha256 hash of bitcoin block header
 * bytes are reversed to bigendian order
 *
 * If header is a Buffer, it is required to 80 bytes long
 * and in standard block header serialized encoding.
 *
 * @returns doule sha256 hash of header bytes reversed
 * @publicbody
 */
function blockHash(header) {
    const data = !Buffer.isBuffer(header) ? serializeBlockHeader(header) : header;
    if (data.length !== 80)
        throw new Error('Block header must be 80 bytes long.');
    return (0, utils_1.doubleSha256HashLE)(data).reverse();
}
exports.blockHash = blockHash;
/**
 * Serializes a block header as an 80 byte Buffer.
 * The exact serialized format is defined in the Bitcoin White Paper
 * such that computing a double sha256 hash of the buffer computes
 * the block hash for the header.
 * @returns 80 byte Buffer
 * @publicbody
 */
function serializeBlockHeader(header, buffer, offset) {
    if (buffer != null) {
        offset || (offset = 0);
        buffer.writeUInt32LE(header.version, offset);
        (0, utils_1.swapByteOrder)(header.previousHash).copy(buffer, offset + 4, 0, 32);
        (0, utils_1.swapByteOrder)(header.merkleRoot).copy(buffer, offset + 36, 0, 32);
        buffer.writeUInt32LE(header.time, offset + 68);
        buffer.writeUInt32LE(header.bits, offset + 72);
        buffer.writeUInt32LE(header.nonce, offset + 76);
        return buffer.subarray(offset, offset + 80);
    }
    else {
        const data = Buffer.concat([
            (0, utils_1.convertUint32ToBuffer)(header.version),
            (0, utils_1.swapByteOrder)(header.previousHash),
            (0, utils_1.swapByteOrder)(header.merkleRoot),
            (0, utils_1.convertUint32ToBuffer)(header.time),
            (0, utils_1.convertUint32ToBuffer)(header.bits),
            (0, utils_1.convertUint32ToBuffer)(header.nonce)
        ]);
        return data;
    }
}
exports.serializeBlockHeader = serializeBlockHeader;
/**
 * Deserialize a block header from an 80 byte buffer
 * @publicbody
 */
function deserializeBlockHeader(buffer, offset = 0) {
    const header = {
        version: (0, utils_1.convertBufferToUint32)(buffer.subarray(0 + offset, 4 + offset)),
        previousHash: (0, utils_1.swapByteOrder)(buffer.subarray(4 + offset, 36 + offset)),
        merkleRoot: (0, utils_1.swapByteOrder)(buffer.subarray(36 + offset, 68 + offset)),
        time: (0, utils_1.convertBufferToUint32)(buffer.subarray(68 + offset, 72 + offset)),
        bits: (0, utils_1.convertBufferToUint32)(buffer.subarray(72 + offset, 76 + offset)),
        nonce: (0, utils_1.convertBufferToUint32)(buffer.subarray(76 + offset, 80 + offset))
    };
    return header;
}
exports.deserializeBlockHeader = deserializeBlockHeader;
/**
 * Returns the genesis block for the specified chain.
 * @publicbody
 */
function genesisHeaderHex(chain) {
    return chain === 'main'
        ? {
            version: 1,
            previousHash: '0000000000000000000000000000000000000000000000000000000000000000',
            merkleRoot: '4a5e1e4baab89f3a32518a88c31bc87f618f76673e2cc77ab2127b7afdeda33b',
            time: 1231006505,
            bits: 486604799,
            nonce: 2083236893,
            height: 0,
            hash: '000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f'
        }
        : {
            version: 1,
            previousHash: '0000000000000000000000000000000000000000000000000000000000000000',
            merkleRoot: '4a5e1e4baab89f3a32518a88c31bc87f618f76673e2cc77ab2127b7afdeda33b',
            time: 1296688602,
            bits: 486604799,
            nonce: 414098458,
            height: 0,
            hash: '000000000933ea01ad0ee984209779baaec3ced90fa3f408719526f8d77f4943'
        };
}
exports.genesisHeaderHex = genesisHeaderHex;
/**
 * Returns the genesis block for the specified chain.
 * @publicbody
 */
function genesisBuffer(chain) { return serializeBlockHeader((0, BlockHeaderApi_1.toBlockHeader)(genesisHeaderHex(chain))); }
exports.genesisBuffer = genesisBuffer;
//# sourceMappingURL=blockHeaderUtils.js.map