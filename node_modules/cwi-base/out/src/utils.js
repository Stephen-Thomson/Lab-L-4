"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.transformResultsWithTrust = exports.minDate = exports.maxDate = exports.identityKeyFromPrivateKey = exports.getInputTxIds = exports.asBsvSdkPublickKey = exports.asBsvSdkPrivateKey = exports.asBsvSdkScript = exports.asBsvSdkTx = exports.computeMerkleTreeParent = exports.computeRootFromMerkleProofNodes = exports.writeVarUint32LE = exports.readVarUint32LE = exports.varUintSize = exports.convertBufferToUint32 = exports.convertUint32ToBuffer = exports.swapByteOrder = exports.doubleSha256BE = exports.doubleSha256HashLE = exports.sha256Hash = exports.asString = exports.asBuffer = exports.shuffleArray = exports.randomMinMax = exports.randomBytesBase64 = exports.randomBytesHex = exports.randomBytes = exports.wait = exports.bitsAreSet = exports.stampLogFormat = exports.stampLog = void 0;
const crypto_1 = __importDefault(require("crypto"));
const sdk_1 = require("@bsv/sdk");
const ERR_errors_1 = require("./ERR_errors");
const sdk_ts_1 = require("@babbage/sdk-ts");
Object.defineProperty(exports, "stampLog", { enumerable: true, get: function () { return sdk_ts_1.stampLog; } });
Object.defineProperty(exports, "stampLogFormat", { enumerable: true, get: function () { return sdk_ts_1.stampLogFormat; } });
const verifyHelpers_1 = require("./verifyHelpers");
/**
 * Tests if all `bits` are set in `what`.
 *
 * @param what value being tested for set bits.
 * @param bits union of bits to test.
 * @returns true iff all `bits` are set in `what`
 */
function bitsAreSet(what, bits) {
    return (what & bits) === bits;
}
exports.bitsAreSet = bitsAreSet;
/**
 * Returns an await'able Promise that resolves in the given number of msecs.
 * @publicbody
 */
function wait(msecs) {
    return new Promise(resolve => setTimeout(resolve, msecs));
}
exports.wait = wait;
/**
 * @returns count cryptographically secure random bytes as Buffer
 */
function randomBytes(count) {
    return crypto_1.default.randomBytes(count);
}
exports.randomBytes = randomBytes;
/**
 * @returns count cryptographically secure random bytes as hex encoded string
 */
function randomBytesHex(count) {
    return randomBytes(count).toString('hex');
}
exports.randomBytesHex = randomBytesHex;
/**
 * @returns count cryptographically secure random bytes as base64 encoded string
 */
function randomBytesBase64(count) {
    return randomBytes(count).toString('base64');
}
exports.randomBytesBase64 = randomBytesBase64;
/**
 * @param min minimum value to return
 * @param max greater than maximum value returned
 * @returns a weakly randomized value in the range from min to less than max.
 * @throws ERR_INVALID_PARAMETER when max is less than min.
 * @publicbody
 */
function randomMinMax(min, max) {
    if (max < min)
        throw new ERR_errors_1.ERR_INVALID_PARAMETER('max', `less than min (${min}). max is (${max})`);
    return Math.floor(Math.random() * (max - min + 1) + min);
}
exports.randomMinMax = randomMinMax;
/**
 * Shuffle an array of items.
 *
 * This is not a cryptographically strong shuffle.
 *
 * Run time is O(n)
*
 * @returns original `array` with contents shuffled
 * @publicbody
 */
function shuffleArray(array) {
    let currentIndex = array.length;
    let temporaryValue;
    let randomIndex;
    // While there remain elements to shuffle...
    while (currentIndex !== 0) {
        // Pick a remaining element...
        randomIndex = Math.floor(Math.random() * currentIndex);
        currentIndex -= 1;
        // And swap it with the current element.
        temporaryValue = array[currentIndex];
        array[currentIndex] = array[randomIndex];
        array[randomIndex] = temporaryValue;
    }
    return array;
}
exports.shuffleArray = shuffleArray;
/**
 * Coerce a value to Buffer if currently encoded as a string or
 * @param val Buffer or string or number[]. If string, encoding param applies. If number[], Buffer.from constructor is used.
 * @param encoding defaults to 'hex'. Only applies to val of type string
 * @returns input val if it is a Buffer or new Buffer from string val
 * @publicbody
 */
function asBuffer(val, encoding) {
    let b;
    if (Buffer.isBuffer(val))
        b = val;
    else if (typeof val === 'string')
        b = Buffer.from(val, encoding !== null && encoding !== void 0 ? encoding : 'hex');
    else
        b = Buffer.from(val);
    return b;
}
exports.asBuffer = asBuffer;
/**
 * Coerce a value to an encoded string if currently a Buffer or number[]
 * @param val Buffer or string or number[]. If string, encoding param applies. If number[], Buffer.from constructor is used.
 * @param encoding defaults to 'hex'
 * @returns input val if it is a string; or if number[], first converted to Buffer then as Buffer; if Buffer encoded using `encoding`
 * @publicbody
 */
function asString(val, encoding) {
    if (Array.isArray(val))
        val = Buffer.from(val);
    return Buffer.isBuffer(val) ? val.toString(encoding !== null && encoding !== void 0 ? encoding : 'hex') : val;
}
exports.asString = asString;
/**
 * Calculate the SHA256 hash of a Buffer.
 * @returns sha256 hash of buffer contents.
 * @publicbody
 */
function sha256Hash(buffer) {
    return crypto_1.default.createHash('sha256').update(buffer).digest();
}
exports.sha256Hash = sha256Hash;
/**
 * Calculate the SHA256 hash of the SHA256 hash of a Buffer.
 * @param data is Buffer or hex encoded string
 * @returns double sha256 hash of buffer contents, byte 0 of hash first.
 * @publicbody
 */
function doubleSha256HashLE(data, encoding) {
    return sha256Hash(sha256Hash(asBuffer(data, encoding)));
}
exports.doubleSha256HashLE = doubleSha256HashLE;
/**
 * Calculate the SHA256 hash of the SHA256 hash of a Buffer.
 * @param data is Buffer or hex encoded string
 * @returns reversed (big-endian) double sha256 hash of data, byte 31 of hash first.
 * @publicbody
 */
function doubleSha256BE(data, encoding) {
    return doubleSha256HashLE(data, encoding).reverse();
}
exports.doubleSha256BE = doubleSha256BE;
/**
 * Returns a copy of a Buffer with byte order reversed.
 * @returns new buffer with byte order reversed.
 * @publicbody
 */
function swapByteOrder(buffer) {
    return Buffer.from(buffer).reverse();
}
exports.swapByteOrder = swapByteOrder;
/**
 * @param num a number value in the Uint32 value range
 * @param littleEndian true for little-endian byte order in Buffer
 * @returns four byte buffer with Uint32 number encoded
 * @publicbody
 */
function convertUint32ToBuffer(num, littleEndian = true) {
    const arr = new ArrayBuffer(4);
    const view = new DataView(arr);
    view.setUint32(0, num, littleEndian); // byteOffset = 0
    return Buffer.from(arr);
}
exports.convertUint32ToBuffer = convertUint32ToBuffer;
/**
 * @param buffer four byte buffer with Uint32 number encoded
 * @param littleEndian true for little-endian byte order in Buffer
 * @returns a number value in the Uint32 value range
 * @publicbody
 */
function convertBufferToUint32(buffer, littleEndian = true) {
    const arr = buffer.buffer.slice(buffer.byteOffset, buffer.byteOffset + buffer.byteLength);
    const view = new DataView(arr);
    return view.getUint32(0, littleEndian);
}
exports.convertBufferToUint32 = convertBufferToUint32;
/**
 * Returns the byte size required to encode number as Bitcoin VarUint
 * @publicbody
 */
function varUintSize(val) {
    if (val < 0)
        throw new ERR_errors_1.ERR_BAD_REQUEST();
    return (val <= 0xfc ? 1 : val <= 0xffff ? 3 : val <= 0xffffffff ? 5 : 9);
}
exports.varUintSize = varUintSize;
/**
 * Reads a Bitcoin VarUInt from buffer at an offset.
 *
 * Returns updated offset.
 * @publicbody
 */
function readVarUint32LE(buffer, offset) {
    const b0 = buffer[offset++];
    switch (b0) {
        case 0xff:
            throw new Error('Larger than Uint32 value is not supported at this time.');
        case 0xfe:
            return { val: buffer.readUint32LE(offset), offset: offset + 4 };
        case 0xfd:
            return { val: buffer.readUint16LE(offset), offset: offset + 2 };
        default:
            return { val: b0, offset };
    }
}
exports.readVarUint32LE = readVarUint32LE;
/**
 * Writes a Bitcoin VarUInt to a buffer at an offset.
 *
 * Returns updated offset.
 * @publicbody
 */
function writeVarUint32LE(val, buffer, offset) {
    if (val < 0) {
        throw new Error(`val ${val} must be a non-negative integer.`);
    }
    if (val <= 0xfc) {
        buffer[offset] = val;
        return offset + 1;
    }
    if (val <= 0xffff) {
        buffer[offset] = 0xfd;
        buffer.writeUint16LE(val, offset + 1);
        return offset + 3;
    }
    if (val <= 0xffffffff) {
        buffer[offset] = 0xfe;
        buffer.writeUint32LE(val, offset + 1);
        return offset + 5;
    }
    throw new Error('Larger than Uint32 value is not supported at this time.');
    // buffer[offset] = 0xff
    // buffer.writeBigUint64LE(val, offset + 1)
    // return offset + 9
}
exports.writeVarUint32LE = writeVarUint32LE;
/**
 * Computes merkle root from transaction hash and TSC proof data.
 *
 * Note that it is essential to confirm that the txid is the double sha256 hash of
 * the transaction.
 *
 * To prove that txid is the last transaction in its block, at every level,
 * if computed is left side, then provided must equal computed.
 *
 * Specification Reference: https://tsc.bitcoinassociation.net/standards/merkle-proof-standardised-format/
 *
 * @param index index of transaction being proven in block
 * @param txid hash of transaction being proven
 * @param nodes tip to root, proof provided intermediate hash values
 * @returns computed merkle tree root for comparison to known root.
 */
function computeRootFromMerkleProofNodes(index, txid, nodes) {
    let c = asBuffer(txid);
    const nodesIsBuffer = Buffer.isBuffer(nodes);
    let level = 0;
    let offset = 0;
    for (;; level++) {
        let p;
        if (nodesIsBuffer) {
            if (offset >= nodes.length) {
                break;
            }
            const type = nodes[offset++];
            if (type !== 0 && type !== 1) {
                throw new Error(`Unsuported node type ${type}`);
            }
            p = type === 1 ? c : nodes.subarray(offset, offset + 32);
            if (type === 0) {
                offset += 32;
            }
        }
        else {
            if (level >= nodes.length) {
                break;
            }
            p = nodes[level] === '*' ? c : Buffer.from(nodes[level], 'hex');
        }
        const cIsLeft = index % 2 === 0;
        // Proof is invalid if computed value equals provided value and computed is right side.
        if (!cIsLeft && c.equals(p)) {
            return Buffer.alloc(32);
        }
        c = cIsLeft
            ? computeMerkleTreeParent(c, p)
            : computeMerkleTreeParent(p, c);
        index = Math.floor(index / 2);
    }
    return c;
}
exports.computeRootFromMerkleProofNodes = computeRootFromMerkleProofNodes;
/**
 * Coerce the 32 byte hash value for a merkle tree parent node given its left and right child node hashes.
 *
 * @param leftNode 32 byte hash as hex string or Buffer
 * @param rightNode 32 byte hash as hex string or Buffer
 * @publicbody
 */
function computeMerkleTreeParent(leftNode, rightNode) {
    // if inputs are strings, swap endianness before concatenating
    const leftConc = Buffer.from(asBuffer(leftNode)).reverse();
    const rightConc = Buffer.from(asBuffer(rightNode)).reverse();
    // concatenate leaves
    const concat = Buffer.concat([leftConc, rightConc]);
    // hash the concatenation
    const hash = doubleSha256BE(concat);
    return hash;
}
exports.computeMerkleTreeParent = computeMerkleTreeParent;
/**
 * Coerce a bsv transaction encoded as a hex string, serialized Buffer, or Transaction to Transaction
 * If tx is already a Transaction, just return it.
 * @publicbody
 */
function asBsvSdkTx(tx) {
    if (Buffer.isBuffer(tx)) {
        tx = sdk_1.Transaction.fromHex(asString(tx));
    }
    else if (typeof tx === 'string') {
        tx = sdk_1.Transaction.fromHex(tx);
    }
    return tx;
}
exports.asBsvSdkTx = asBsvSdkTx;
/**
 * Coerce a bsv script encoded as a hex string, serialized Buffer, or Script to Script
 * If script is already a Script, just return it.
 * @publicbody
 */
function asBsvSdkScript(script) {
    if (Buffer.isBuffer(script)) {
        script = sdk_1.Script.fromHex(asString(script));
    }
    else if (typeof script === 'string') {
        script = sdk_1.Script.fromHex(script);
    }
    return script;
}
exports.asBsvSdkScript = asBsvSdkScript;
/**
 * @param privKey bitcoin private key in 32 byte hex string form
 * @returns @bsv/sdk PrivateKey
 */
function asBsvSdkPrivateKey(privKey) {
    return sdk_1.PrivateKey.fromString(privKey, 'hex');
}
exports.asBsvSdkPrivateKey = asBsvSdkPrivateKey;
/**
 * @param pubKey bitcoin public key in standard compressed key hex string form
 * @returns @bsv/sdk PublicKey
 */
function asBsvSdkPublickKey(pubKey) {
    return sdk_1.PublicKey.fromString(pubKey);
}
exports.asBsvSdkPublickKey = asBsvSdkPublickKey;
/**
 * For a bitcoin transaction in hex string, Buffer or parsed Transaction form,
 *
 * returns deduplicated array of the input's outpoint transaction hashes (txids).
 *
 * @publicbody
 */
function getInputTxIds(tx) {
    tx = asBsvSdkTx(tx);
    const txids = {};
    for (const input of tx.inputs) {
        txids[(0, verifyHelpers_1.verifyTruthy)(input.sourceTXID)] = true;
    }
    return Object.keys(txids);
}
exports.getInputTxIds = getInputTxIds;
/**
 * Returns the Identity Key value associated with a private key.
 * @param privKey as hex encoded 32 byte value
 * @returns hex encoded Identity Key.
 */
function identityKeyFromPrivateKey(privKey) {
    const priv = sdk_1.PrivateKey.fromString(privKey, 'hex');
    const identityKey = priv.toPublicKey().toString();
    return identityKey;
}
exports.identityKeyFromPrivateKey = identityKeyFromPrivateKey;
/**
 * returns most recent of two dates or undefined if both are null or undefined.
 * @publicbody
 */
function maxDate(d1, d2) {
    if (d1 == null)
        return (d2 != null) ? d2 : undefined;
    if (d2 == null)
        return (d1 != null) ? d1 : undefined;
    return d1 > d2 ? d1 : d2;
}
exports.maxDate = maxDate;
/**
 * returns least recent of two dates or undefined if either date is null or undefined.
 * @publicbody
 */
function minDate(d1, d2) {
    if (d1 == null || d2 == null)
        return undefined;
    return d1 < d2 ? d1 : d2;
}
exports.minDate = minDate;
/**
 * Helper function for evaluating if an entity meets the trust threshold of the user
 * @param {object} obj all params given in an object
 * @param {object} obj.settings contains the user's setting information
 * @param {object} obj.results the results returned from a Signia lookup
 */
function transformResultsWithTrust({ settings, certifiers, results }) {
    // Group by publicKey and sum trust points, filtering early
    const identityGroups = {};
    const finalResults = [];
    const certifierCache = {};
    const trustThreshold = settings.trustThreshold;
    // Group by subject and sum trust points
    results.forEach(result => {
        const { subject, certifier } = result;
        if (!subject || !certifier) {
            return;
        }
        // Lookup or cache certifier details
        if (!certifierCache[certifier]) {
            const certifierDetails = certifiers.find(x => x.publicKey === certifier);
            if (!certifierDetails) {
                return;
            }
            certifierCache[certifier] = {
                name: certifierDetails.name,
                icon: certifierDetails.icon,
                note: certifierDetails.note,
                publicKey: certifierDetails.publicKey,
                trust: certifierDetails.trust
            };
        }
        if (!identityGroups[subject]) {
            identityGroups[subject] = { totalTrust: 0, members: [] };
        }
        // Use the cached certifier details and include it in the result
        const resultWithCertifier = Object.assign(Object.assign({}, result), { certifier: certifierCache[certifier] });
        // Use the cached trust value
        identityGroups[subject].totalTrust += certifierCache[certifier] ? certifierCache[certifier].trust : 0;
        identityGroups[subject].members.push(resultWithCertifier);
    });
    // Filter groups by threshold and flatten
    Object.values(identityGroups).forEach(group => {
        if (group.totalTrust >= trustThreshold) {
            finalResults.push(...group.members);
        }
    });
    // Sort the final results in descending order by trust (using the cached trust values)
    finalResults.sort((a, b) => b.certifier.trust - a.certifier.trust);
    return finalResults;
}
exports.transformResultsWithTrust = transformResultsWithTrust;
//# sourceMappingURL=utils.js.map