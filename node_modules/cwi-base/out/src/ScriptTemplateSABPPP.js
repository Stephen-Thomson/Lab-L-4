"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ScriptTemplateSABPPP = void 0;
const _1 = require(".");
const sdk_1 = require("@bsv/sdk");
const sendover_1 = require("sendover");
class ScriptTemplateSABPPP {
    constructor(params) {
        this.params = params;
        this.protocol = '2-3241645161d8';
        this.p2pkh = new sdk_1.P2PKH();
        (0, _1.verifyTruthy)(params.derivationPrefix);
        (0, _1.verifyTruthy)(params.derivationSuffix);
    }
    /**
     * Combine inputs per protocol 3241645161d8 to generate an 'invoice' string used for cryptographic key generation.
     */
    invoice() {
        const invoice = `${this.protocol}-${this.params.derivationPrefix} ${this.params.derivationSuffix}`;
        return invoice;
    }
    lock(lockerPrivKey, unlockerPubKey) {
        const derivedAddress = (0, sendover_1.getPaymentAddress)({
            senderPrivateKey: lockerPrivKey,
            recipientPublicKey: unlockerPubKey,
            invoiceNumber: this.invoice(),
            returnType: 'address'
        });
        const r = this.p2pkh.lock(derivedAddress);
        return r;
    }
    unlock(unlockerPrivKey, lockerPubKey, sourceSatoshis, lockingScript) {
        // Derive the key used to unlock funds
        const derivedPrivateKey = (0, sendover_1.getPaymentPrivateKey)({
            recipientPrivateKey: unlockerPrivKey,
            senderPublicKey: lockerPubKey,
            invoiceNumber: this.invoice(),
            returnType: "hex"
        });
        const r = this.p2pkh.unlock((0, _1.asBsvSdkPrivateKey)(derivedPrivateKey), "all", false, sourceSatoshis, lockingScript);
        return r;
    }
}
exports.ScriptTemplateSABPPP = ScriptTemplateSABPPP;
//# sourceMappingURL=ScriptTemplateSABPPP.js.map