"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.deriveKey = void 0;
const _1 = require(".");
const babbage_bsv_1 = __importDefault(require("babbage-bsv"));
/**
 * This function derives the child key given the root key.
 *
 * The rootKey, identityKey, publicKey, and sharedSymmetricKey flags can be combined with
 * counterparty, protocolID and keyID to derive the needed keys.
 *
 * @return Hex string of key to return
 */
function deriveKey(params) {
    let counterparty = params.counterparty;
    const { key, protocolID, keyID, derivationIdentity = '1', rootKey = false, identityKey = false, publicKey = false, forSelf = false, sharedSymmetricKey = false, deriveFromRoot = true, revealCounterpartyLinkage = false, revealPaymentLinkage = false } = params;
    if (rootKey) {
        if (publicKey) {
            return babbage_bsv_1.default.PrivateKey.fromBuffer(Buffer.from(key))
                .publicKey.toString();
        }
        else {
            return Buffer.from(key).toString('hex');
        }
    }
    const rootPrivate = babbage_bsv_1.default.PrivateKey.fromBuffer(Buffer.from(key));
    let identity;
    if (deriveFromRoot) {
        identity = rootPrivate;
    }
    else {
        identity = (0, _1.getPaymentPrivateKey)({
            recipientPrivateKey: rootPrivate,
            senderPublicKey: rootPrivate.publicKey,
            invoiceNumber: derivationIdentity,
            returnType: 'babbage-bsv'
        });
    }
    if (identityKey) {
        if (publicKey) {
            return babbage_bsv_1.default.PrivateKey.fromBuffer(identity.toBuffer({ size: 32 })).publicKey.toString();
        }
        else {
            return identity.toHex({ size: 32 });
        }
    }
    if (!counterparty) {
        throw new Error('counterparty must be self, anyone or a public key!');
    }
    else if (counterparty === 'self') {
        if (revealCounterpartyLinkage) {
            throw new Error('Counterparty secrets cannot be revealed for counterparty=self as specified by BRC-69');
        }
        counterparty = babbage_bsv_1.default.PrivateKey.fromBuffer(identity.toBuffer({ size: 32 })).publicKey;
    }
    else if (counterparty === 'anyone') {
        if (sharedSymmetricKey) {
            throw new Error('Symmetric keys (such as encryption keys or HMAC keys) should not be derivable by everyone, because messages would be decryptable by anyone who knows the identity public key of the user, and HMACs would be similarly forgeable.');
        }
        counterparty = babbage_bsv_1.default.PrivateKey.fromHex('0000000000000000000000000000000000000000000000000000000000000001').publicKey;
    }
    // If the counterparty secret is requested, it's worth making absolutely certain this is not counterparty=self, even if passed in manually
    // This process ensures that whatever formats the keys are in, if the derivations produce the same child keys, the counterparty secret is not evealed
    if (revealCounterpartyLinkage) {
        const self = babbage_bsv_1.default.PrivateKey.fromBuffer(identity.toBuffer({ size: 32 })).publicKey;
        const keyDerivedBySelf = (0, _1.getPaymentPrivateKey)({
            recipientPrivateKey: identity,
            senderPublicKey: self,
            invoiceNumber: 'test',
            returnType: 'hex'
        });
        const keyDerivedByCounterparty = (0, _1.getPaymentPrivateKey)({
            recipientPrivateKey: identity,
            senderPublicKey: counterparty,
            invoiceNumber: 'test',
            returnType: 'hex'
        });
        if (keyDerivedBySelf === keyDerivedByCounterparty) {
            throw new Error('Counterparty secrets cannot be revealed for counterparty=self as specified by BRC-69');
        }
    }
    const normalizedProtocolID = (0, _1.normalizeProtocol)(protocolID);
    const invoiceNumber = (0, _1.getProtocolInvoiceNumber)({ protocolID: normalizedProtocolID, keyID });
    let derivedPublicKey;
    if (sharedSymmetricKey || publicKey) {
        if (forSelf) {
            const ourPrivateKey = (0, _1.getPaymentPrivateKey)({
                recipientPrivateKey: identity,
                senderPublicKey: counterparty,
                invoiceNumber,
                returnType: 'babbage-bsv',
                revealCounterpartyLinkage,
                revealPaymentLinkage
            });
            if (revealCounterpartyLinkage || revealPaymentLinkage) {
                return ourPrivateKey;
            }
            return babbage_bsv_1.default.PrivateKey.fromBuffer(ourPrivateKey.toBuffer({ size: 32 })).publicKey.toString();
        }
        else {
            derivedPublicKey = (0, _1.getPaymentAddress)({
                senderPrivateKey: identity,
                recipientPublicKey: counterparty,
                invoiceNumber,
                returnType: 'babbage-bsv',
                revealCounterpartyLinkage,
                revealPaymentLinkage
            });
            if (revealCounterpartyLinkage || revealPaymentLinkage) {
                return derivedPublicKey;
            }
        }
    }
    if (publicKey) {
        if (sharedSymmetricKey) {
            throw new Error('Cannot return a public key for a symmetric key!');
        }
        return derivedPublicKey.toString();
    }
    const derivedPrivateKey = (0, _1.getPaymentPrivateKey)({
        recipientPrivateKey: identity,
        senderPublicKey: counterparty,
        invoiceNumber,
        returnType: 'babbage-bsv',
        revealCounterpartyLinkage,
        revealPaymentLinkage
    });
    if (revealCounterpartyLinkage || revealPaymentLinkage) {
        return derivedPrivateKey;
    }
    if (!sharedSymmetricKey) {
        return derivedPrivateKey.toHex({ size: 32 });
    }
    const sharedSecret = derivedPublicKey.point.mul(derivedPrivateKey).toBuffer().slice(1);
    return sharedSecret.toString('hex');
}
exports.deriveKey = deriveKey;
//# sourceMappingURL=deriveKey.js.map